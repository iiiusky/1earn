# 包管理

---

**软件包是什么？**

软件包这个概念是用来解决在软件安装、升级过程中的复杂性的。包将软件安装升级中需要的多个数据文件合并成一个单独的文件，这将便于传输和（通过压缩文件来）减小存储空间，包中的二进制可执行文件已根据开发者所选择的编译标识预编译。包本身包括了所有需要的元数据，如软件的名字、软件的说明、版本号，以及要运行这个软件所需要的依赖包等等。

不同流派的 Linux 发行版都创造了它们自己的包格式，其中最常用的包格式有：
- .deb：这种包格式由 Debian、Ubuntu、Linux Mint 以及其它的变种使用。这是最早被发明的包类型。
- .rpm：这种包格式最初被称作红帽包管理器（LCTT 译注： 取自英文的首字母）。使用这种包的 Linux 发行版有 Red Hat、Fedora、SUSE 以及其它一些较小的发行版。
- .tar.xz：这种包格式只是一个软件压缩包而已，这是 Arch Linux 所使用的格式。
尽管上述的包格式自身并不能直接管理软件的依赖问题，但是它们的出现将 Linux 软件包管理向前推进了一大步。

**为什么要有包管理工具**

今天，每个可计算设备都会使用某种软件来完成预定的任务。在软件开发的上古时期，为了找出软件中的“虫”和其它缺陷，软件会被严格的测试。在近十年间，软件被通过互联网来频繁分发，以试图通过持续不断的安装新版本的软件来解决软件的缺陷问题。在很多情况下，每个独立的应用软件都有其自带的更新器。而其它一些软件则让用户自己去搞明白如何获取和升级软件。

Linux 较早采用了维护一个中心化的软件仓库来发布软件更新这种做法，用户可以在这个软件仓库里查找并安装软件。

**那么在包管理器出现之前在 Linux 上是如何安装软件的呢？**

曾几何时，软件都是通过 FTP 或邮件列表来分发的（最终这些发布方式在互联网的迅猛发展下都演化成为一个个现今常见的软件发布网站）。（一般在一个 tar 文件中）只有一个非常小的文件包含了创建二进制的说明。你需要做的是先解压这个包，然后仔细阅读当中的 README 文件， 如果你的系统上恰好有 GCC或者其它厂商的 C 编译器的话，你得首先运行 ./configure 脚本，并在脚本后添加相应的参数，如库函数的路径、创建可执行文件的路径等等。除此之外，这个配置过程也会检查你操作系统上的软件依赖是否满足安装要求。如果缺失了任何主要的依赖，该配置脚本会退出不再继续安装，直到你满足了该依赖。如果该配置脚本正常执行完毕，将会创建一个 Makefile 文件。

当有了一个 Makefile 文件时， 你就可以接下去执行 make 命令（该命令由你所使用的编译器提供）。make 命令也有很多参数，被称为 make 标识，这些标识能为你的系统优化最终生成出来的二进制可执行文件。在计算机世界的早期，这些优化是非常重要的，因为彼时的计算机硬件正在为了跟上软件迅速的发展而疲于奔命。今日今时，编译标识变得更加通用而不是为了优化哪些具体的硬件型号，这得益于现代硬件和现代软件相比已经变得成本低廉，唾手可得。

最后，在 make 完成之后， 你需要运行 make install （或 sudo make install） 来“真正”将这个软件安装到你的系统上。可以想象，为你系统上的每一个软件都执行上述的流程将是多么无聊费时，更不用说如果更新一个已经安装的软件将会多复杂，多么需要精力投入。

**软件仓库到底是什么？**

多年以前（当智能电话还没有像现在这样流行时），非 Linux 世界的用户是很难理解软件仓库的概念的。甚至今时今日，大多数完全工作在 Windows 下的用户还是习惯于打开浏览器，搜索要安装的软件（或升级包），下载然后安装。但是，智能电话传播了软件“商店”这样一个概念。智能电话用户获取软件的方式和包管理器的工作方式已经非常相近了。些许不同的是，尽管大多数软件商店还在费力美化它的图形界面来吸引用户，大多数 Linux 用户还是愿意使用命令行来安装软件。总而言之，软件仓库是一个中心化的可安装软件列表，上面列举了在当前系统中预先配置好的软件仓库里所有可以安装的软件。下面我们举一些例子来说在各个不同的 Linux 发行版下如何在对应的软件仓库里搜寻某个特定的软件（输出有截断）。

---

# apt 和 apt-get

apt 的全称是 Advanced Packaging Tool 是 Linux 系统下的一款安装包管理工具.

**apt 和 apt-get 命令之间的区别**

没啥区别,建议使用 apt

**PPA**

PPA 表示个人软件包存档

软件仓库是一组文件，其中包含各种软件及其版本的信息，以及校验和等其他一些详细信息。每个版本的 Ubuntu 都有自己的四个官方软件仓库：
- Main - Canonical 支持的自由开源软件。
- Universe - 社区维护的自由开源软件。
- Restricted - 设备的专有驱动程序。
- Multiverse - 受版权或法律问题限制的软件。

见此 http://archive.ubuntu.com/ubuntu/dists/

所以，PPA 基本上是一个包含软件信息的网址。那你的系统又是如何知道这些仓库的位置的呢？

这些信息存储在 `/etc/apt` 目录中的 sources.list 文件中。如果查看此文件的内容，你就会看到里面有软件仓库的网址。# 开头的行将被忽略。

这样的话，当你运行 `sudo apt update` 命令时，你的系统将使用 APT 工具 来检查软件仓库并将软件及其版本信息存储在缓存中。当你使用 `sudo apt install package_name` 命令时，它通过该信息从实际存储软件的网址获取该软件包。

如果软件仓库中没有关于某个包的信息，你将看到如下错误：
```
E: Unable to locate package
```

```bash
add-apt-repository ppa:XXX/XXX  # 将 PPA 仓库添加到列表中。
```

**常见问题**
```
E: 无法获得锁 /var/lib/apt/lists/lock - open (11: 资源暂时不可用)
E: 无法对目录 /var/lib/apt/lists/ 加锁
E: 无法获得锁 /var/lib/dpkg/lock - open (11: 资源暂时不可用)
E: 无法锁定管理目录(/var/lib/dpkg/)，是否有其他进程正占用它？
```

出现这个问题的原因可能是有另外一个程序正在运行，由于它在运行时，会占用软件源更新时的系统锁（以下称“系统更新锁”，此锁文件在“/var/lib/apt/lists/”目录下），而当有新的apt-get进程生成时，就会因为得不到系统更新锁而出现"E: 无法获得锁 /var/lib/apt/lists/lock - open (11: Resource temporarily unavailable)"错误提示！

而导致资源被锁的原因，可能是上次安装时没正常完成，而导致出现此状况。

解决方法
```bash
rm -rf /var/cache/apt/archives/lock
rm -rf /var/lib/dpkg/lock-frontend
rm -rf /var/lib/dpkg/lock		# 强制解锁占用
```

---

# dnf

DNF(Dandified Yum)是一种的 RPM 软件包管理器。

DNF包管理器克服了 YUM 包管理器的一些瓶颈，提升了包括用户体验，内存占用，依赖分析，运行速度等多方面的内容。

DNF使用 RPM,libsolv 和 hawkey 库进行包管理操作，Fedora22 已经默认使用 DNF。

---

# pacman

pacman 是 Arch 的包管理工具.

---

# snap

Snappy 是一个软件部署和软件包管理系统，最早由 Canonical 公司为了 Ubuntu 移动电话操作系统而设计和构建。其包称为“snap”，工具名为“snapd”，可在多种 Linux 发行版上运行，完成发行上游主导的软件部署。该系统的设计面向手机、云、物联网和台式机。

---

# yum

yum 命令是在 Fedora 和 RedHat 以及 SUSE 中基于 rpm 的软件包管理器

**常见问题**
```bash
/var/run/yum.pid 已被锁定,PID 为 xxxx 的另一个程序正在运行.
```

解决方法
```bash
rm -f /var/run/yum.pid
```

---

# Zypper

zypper 是一个简单易用的命令行包管理器,它使用了一个软件包管理库叫做 libzypp 。Zypper 能够操作软件安装源 (比如 Build Service 或 标准 openSUSE 安装源 ), 搜索软件包，安装，删除，或更新软件包等等。它能够作为独立软件使用，也可以在脚本中使用，或被其他软件使用。

---

**Source & Reference**
- [包管理器的进化](https://linux.cn/article-9931-1.html)
- [Ubuntu PPA 使用指南 ](https://linux.cn/article-10456-1.html)
